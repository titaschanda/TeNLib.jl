var documenterSearchIndex = {"docs":
[{"location":"mps/example_dmrg.html#Example:-DMRG","page":"Example: DMRG","title":"Example: DMRG","text":"","category":"section"},{"location":"mps/example_dmrg.html#Ground-state-search","page":"Example: DMRG","title":"Ground state search","text":"","category":"section"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"A straight-forward DMRG can be performed as follows.","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"using ITensors\nusing TeNLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpStrings()\n    \n    for j=1:N-1\n        os += 1, \"Sz\" => j, \"Sz\" => j+1\n        os += 0.5, \"S+\" => j, \"S-\" => j+1\n        os += 0.5, \"S-\" => j, \"S+\" => j+1\n    end\n    \n    H = CouplingModel(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    params = DMRGParams(;nsweeps = [10, 10], maxdim = [20, 50],\n                        cutoff = 1e-14, noise = 1e-3, noisedecay = 2,\n                        disable_noise_after = 5)\n\n    # dmrg2 for two-site DMRG\n    en, psi = dmrg2(psi0, H, params)\n\n    # or dmrg1 for single-site DMRG\n    # en, psi = dmrg1(psi0, H, params)\nend","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Here, we have used OpStrings and CouplingModel. Alternatively, standard OpSum and MPO can be used.","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Instead of using such higher-level code, one can also use lower-level functions for a better control.","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"sysenv = StateEnvs(psi0, H)\nnsite = 2 # two-site update\nswdata = dmrg!(sysenv, params, nsite)\n\n# Get energy from `Sweepdata`\nenergy = swdata.energy[end]\n\n# take a shallow copy of the MPS\n# if the `StateEnvs` will be updated later again\npsi = getpsi(sysenv)\n\n# Alternatively, take the psi from `StateEnvs` itself.\n# NOTE: This can crash the simulation, if the MPS is modified (e.g., in measurements)\n# and `StateEnvs` is going to be updated later.\n# psi = sysenv.psi","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Using such lower-level function, one can restart the simulation at later times (e.g., by saving the StateEnvs using Serialization.jl), or one can perform updateH! to slowly change the Hamiltonian during DMRG simulations.","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Global Subspace Expansion can also be used to get rid of nasty local minimas (if needed).","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"krylov_extend!(sysenv; extension_applyH_maxdim = 40)","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Note: Global Subspace Expansion can result into huge MPS bond dimension. That is why the named input parameters of krylov_extend! should be chosen carefully.","category":"page"},{"location":"mps/example_dmrg.html#Excited-state-DMRG","page":"Example: DMRG","title":"Excited state DMRG","text":"","category":"section"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Excited state DMRG is also straightforword.","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"# Given a ground state `psi_gr`, initial MPS `psi0`,\n# and a Hamiltonian `H`\n\n# dmrg2 for two-site DMRG\nen, psi = dmrg2(psi0, H, [psi_gr], params; weight = 10.0)\n\n# or dmrg1 for single-site DMRG\n# en, psi = dmrg1(psi0, H, [psi_gr], params; weight = 10.0)","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"Similarly, using StateEnvs:","category":"page"},{"location":"mps/example_dmrg.html","page":"Example: DMRG","title":"Example: DMRG","text":"sysenv_ex = StateEnvs(psi0, H, [psi_gr]; weight = 10.0)\nnsite = 2 # two-site update\n\nswdata_ex = dmrg!(sysenv_ex, params, nsite)\n\n# Get energy from `Sweepdata`\nenergy1 = swdata_ex.energy[end]\n\n# take a shallow copy of the MPS\n# if the `StateEnvs` will be updated later again\npsi1 = getpsi(sysenv_ex)\n\n# Alternatively, take the psi from `StateEnvs` itself.\n# NOTE: This can crash the simulation, if the MPS is modified (e.g., in measurements)\n# and `StateEnvs` is going to be updated later.\n# psi1 = sysenv_ex.psi","category":"page"},{"location":"mps/tdvp.html#Performing-TDVP","page":"Performing TDVP","title":"Performing TDVP","text":"","category":"section"},{"location":"mps/tdvp.html#TDVPEngine","page":"Performing TDVP","title":"TDVPEngine","text":"","category":"section"},{"location":"mps/tdvp.html","page":"Performing TDVP","title":"Performing TDVP","text":"TeNLib defines a struct, called TDVPEngine, to store essential data during TDVP sweeps.","category":"page"},{"location":"mps/tdvp.html","page":"Performing TDVP","title":"Performing TDVP","text":"TDVPEngine\nTDVPEngine(psi::MPS, H::T) where T <: Union{MPO, Vector{MPO}, CouplingModel}\nTDVPEngine(psi::MPS, H::T, Ms::Vector{MPS}; weight::Float64) where T <: Union{MPO, Vector{MPO}, CouplingModel}\ngetpsi(engine::TDVPEngine)\nsweepcount(engine::TDVPEngine)\ngetenergy(engine::TDVPEngine)\ngetentropy(engine::TDVPEngine)\nmaxchi(engine::TDVPEngine)\ntotalerror(engine::TDVPEngine)\nsweeperror(engine::TDVPEngine)\nkrylov_extend!(engine::TDVPEngine{ProjMPO}; kwargs...)\nsweepdata(engine::TDVPEngine)\nabstime(engine::TDVPEngine)\nupdateH!(engine::TDVPEngine, H::T; recalcEnv::Bool = true) where T <: Union{MPO, Vector{MPO}, CouplingModel}\nupdateH!(engine::TDVPEngine, H::T, Ms::Vector{MPS}; weight::Float64, recalcEnv::Bool = true) where T <: Union{MPO, Vector{MPO}, CouplingModel}\nBase.copy(engine::TDVPEngine)","category":"page"},{"location":"mps/tdvp.html#TeNLib.TDVPEngine","page":"Performing TDVP","title":"TeNLib.TDVPEngine","text":"mutable struct TDVPEngine{T <: Union{ProjMPO,\n                                     ProjMPOSum2,\n                                     ProjMPO_MPS2,\n                                     ProjMPOSum_MPS,\n                                     ProjCouplingModel,\n                                     ProjCouplingModel_MPS}}\n\nHolds the MPS state, SweepData, and absolute elpased time for TDVP simulations.\n\nsysenv::StateEnvs: Holds the state psi and environments PH.\nswdata::SweepData: Holds the historical data after each (full)sweep.\nabstime::Float64: Absolute elapsed time.\n\n\n\n\n\n","category":"type"},{"location":"mps/tdvp.html#TeNLib.TDVPEngine-Union{Tuple{T}, Tuple{MPS, T}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TeNLib.TDVPEngine","text":"function TDVPEngine(psi::MPS, H::{T}) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nConstructor of the TDVPEngine from different forms of Hamiltonians.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.TDVPEngine-Union{Tuple{T}, Tuple{MPS, T, Vector{MPS}}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TeNLib.TDVPEngine","text":"function TDVPEngine(psi::MPS, H::T, Ms::Vector{MPS};\n                    weight::Float64) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nConstructor of TDVPEngine from different forms of Hamiltonians and a vector of MPS.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.getpsi-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.getpsi","text":"function getpsi(engine::TDVPEngine)\n\nReturns (shallow copy of) the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.sweepcount-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.sweepcount","text":"function sweepcount(engine::TDVPEngine)\n\nReturns the number of sweeps performed.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.getenergy-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.getenergy","text":"function getenergy(engine::TDVPEngine)\n\nReturns the energy of the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.getentropy-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.getentropy","text":"function getentropy(engine::TDVPEngine)\n\nReturns the mid-chain entropy of the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.maxchi-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.maxchi","text":"function maxchi(engine::TDVPEngine)\n\nReturns the maximum bond/link dimension of the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.totalerror-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.totalerror","text":"function totalerror(engine::TDVPEngine)\n\nReturns the sum of the truncation errors of all the sweeps performed.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.sweeperror-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.sweeperror","text":"function sweeperror(engine::TDVPEngine)\n\nReturns the truncation error in the last sweep.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.krylov_extend!-Tuple{TDVPEngine{ProjMPO}}","page":"Performing TDVP","title":"TeNLib.krylov_extend!","text":"function krylov_extend!(engine::TDVPEngine{ProjMPO}; kwargs...)\n\nPerforms Global Subspace Expansion.\n\nArguments and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.sweepdata-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.sweepdata","text":"function sweepdata(engine::TDVPEngine)\n\nReturns the (shallow copy of) SweepData.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.abstime-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TeNLib.abstime","text":"function abstime(engine::TDVPEngine)\n\nReturns the absolute elapsed time.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.updateH!-Union{Tuple{T}, Tuple{TDVPEngine, T}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TeNLib.updateH!","text":"function updateH!(engine::TDVPEngine, H::T;\n                  recalcEnv::Bool = true) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nUpdate Hamiltonian H in engine::TDVPEngine. If recalcEnv = false, it reuses previous environments. recalcEnv = false is only defined when the TDVPEngine is created from a single MPO.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#TeNLib.updateH!-Union{Tuple{T}, Tuple{TDVPEngine, T, Vector{MPS}}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TeNLib.updateH!","text":"function updateH!(engine::TDVPEngine, H::T, Ms::Vector{MPS};\n                  weight::Float64,\n                  recalcEnv::Bool = true) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nUpdate Hamiltonian H in engine::TDVPEngine. recalcEnv = false is not supported.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#Base.copy-Tuple{TDVPEngine}","page":"Performing TDVP","title":"Base.copy","text":"Base.copy(engine::TDVPEngine)\n\nShallow copy of TDVPEngine.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp.html#tdvpsweep!","page":"Performing TDVP","title":"tdvpsweep!","text":"","category":"section"},{"location":"mps/tdvp.html","page":"Performing TDVP","title":"Performing TDVP","text":"tdvpsweep!","category":"page"},{"location":"mps/tdvp.html#TeNLib.tdvpsweep!","page":"Performing TDVP","title":"TeNLib.tdvpsweep!","text":"tdvpsweep!(engine::TDVPEngine, time_step::Union{Float64, ComplexF64}; \n           nsite::Union{Int, String} = \"dynamic\", \n           solver = exp_solver,\n           kwargs...)::Nothing\n\nPerforms one TDVP sweep. Computes ψ' = exp(time_step * H) * ψ. Therefore, for real-time dynamics with step dt, time_step should be -im * dt. \n\nArguments:\n\nengine::TDVPEngine.\ntime_step::Union{Float64, ComplexF64}.\nnsite::Union{Int, String} = \"dynamic\": For two or one site sweeps, nsite=2 or nsite=1 respectively. For nsite=\"dynamic\", dynamic_fullsweep! is performed.\nsolver = exp_solver: Only exp_solver is supported now.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\neigthreshold::Float64 = 1E-12. Only applicable for nsite = \"dynamic\" (see dynamic_fullsweep!).\nextendat::Union{Nothing, Int} = nothing: If specified, at every extendatth sweep, Global Subspace Expansion is performed followed by a pure one-site sweep if typeof(sysenv) == StateEnvs{ProjMPO}, else performs a full two-site sweep. Only applicable for nsite = \"dynamic\" (see dynamic_fullsweep!).\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-12.\nsolver_krylovdim::Int = 30.\nsolver_maxiter::Int = 100.\nsolver_outputlevel::Int = 0.: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = true.\nsolver_check_convergence::Bool = true.\n\nArguments for Global Subspace Expansion and their default values:\n\nOnly applicable for nsite = \"dynamic\" (see dynamic_fullsweep!).\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"function"},{"location":"mps/state_envs.html#StateEnvs:-A-container-to-store-the-MPS-and-its-environments","page":"StateEnvs","title":"StateEnvs: A container to store the MPS and its environments","text":"","category":"section"},{"location":"mps/state_envs.html","page":"StateEnvs","title":"StateEnvs","text":"At the lowest-level of abstraction, TeNLib defines StateEnvs to hold an MPS and its environments to be modified in place.","category":"page"},{"location":"mps/state_envs.html","page":"StateEnvs","title":"StateEnvs","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/state_envs.html","page":"StateEnvs","title":"StateEnvs","text":"StateEnvs\ngetpsi(sysenv::StateEnvs)\ngetenv(sysenv::StateEnvs)\nStateEnvs(psi::MPS, H::MPO)\nStateEnvs(psi::MPS, Hs::Vector{MPO})\nStateEnvs(psi::MPS, H::MPO, Ms::Vector{MPS}; weight::Float64)\nStateEnvs(psi::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}; weight::Float64)\nStateEnvs(psi::MPS, H::CouplingModel)\nStateEnvs(psi::MPS, H::CouplingModel, Ms::Vector{MPS}; weight::Float64)\nupdateH!(sysenv::StateEnvs{ProjMPO}, H::MPO; recalcEnv::Bool = true)\nupdateH!(sysenv::StateEnvs{ProjMPOSum2}, Hs::Vector{MPO}; recalcEnv::Bool = true)\nupdateH!(sysenv::StateEnvs{ProjMPO_MPS2}, H::MPO, Ms::Vector{MPS};  weight::Float64, recalcEnv::Bool = true)\nupdateH!(sysenv::StateEnvs{ProjMPOSum_MPS}, H::Vector{MPO}, Ms::Vector{MPS}; weight::Float64, recalcEnv::Bool = true)\nupdateH!(sysenv::StateEnvs{ProjCouplingModel_MPS}, H::CouplingModel, Ms::Vector{MPS}; weight::Float64, recalcEnv::Bool = true)\nnsite(sysenv::StateEnvs)\nset_nsite!(sysenv::StateEnvs, nsite::Int)\nposition!(sysenv::StateEnvs, pos::Int)\nBase.copy(sysenv::StateEnvs)\nBase.length(sysenv::StateEnvs)","category":"page"},{"location":"mps/state_envs.html#TeNLib.StateEnvs","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"mutable struct StateEnvs{T <: Union{ProjMPO,\n                              ProjMPO_MPS2,\n                              ProjMPOSum2,\n                              ProjMPOSum_MPS,\n                              ProjCouplingModel,\n                              ProjCouplingModel_MPS}\n                        }\n    psi::MPS\n    PH::T\nend\n\nHolds the MPS state psi and its environments PH.\n\n\n\n\n\n","category":"type"},{"location":"mps/state_envs.html#TeNLib.getpsi-Tuple{StateEnvs}","page":"StateEnvs","title":"TeNLib.getpsi","text":"function getpsi(sysenv::StateEnvs)\n\nReturns (shallow copy of) the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.getenv-Tuple{StateEnvs}","page":"StateEnvs","title":"TeNLib.getenv","text":"function getenv(sysenv::StateEnvs)\n\nReturns (shallow copy of) the environment PH.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.StateEnvs-Tuple{MPS, MPO}","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::MPO)\n\nConstructor of the StateEnvs from a single MPO.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.StateEnvs-Tuple{MPS, Vector{MPO}}","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"function StateEnvs(psi::MPS, Hs::Vector{MPO})\n\nConstructor of the  StateEnvs from a vector of MPO. Environments are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.StateEnvs-Tuple{MPS, MPO, Vector{MPS}}","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::MPO, Ms::Vector{MPS}; weight::Float64)\n\nConstructor of the StateEnvs from a single MPO and a vector of MPS used for excited state DMRG.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.StateEnvs-Tuple{MPS, Vector{MPO}, Vector{MPS}}","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"function StateEnvs(psi::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}; weight::Float64)\n\nConstructor of the StateEnvs from a vector of MPO and a vector of MPS used for excited state DMRG. Environments for MPOs are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.StateEnvs-Tuple{MPS, CouplingModel}","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::CouplingModel)\n\nConstructor of the StateEnvs from a CouplingModel. Each terms in the CouplingModel are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.StateEnvs-Tuple{MPS, CouplingModel, Vector{MPS}}","page":"StateEnvs","title":"TeNLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::CouplingModel, Ms::Vector{MPS}; weight::Float64)\n\nConstructor of StateEnvs from a CouplingModel and and a vector of MPS used for excited state DMRG. Each terms in the CouplingModel are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.updateH!-Tuple{StateEnvs{ProjMPO}, MPO}","page":"StateEnvs","title":"TeNLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPO}, H::MPO; recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. If recalcEnv = false, it reuses previous environments.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.updateH!-Tuple{StateEnvs{ProjMPOSum2}, Vector{MPO}}","page":"StateEnvs","title":"TeNLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPOSum2}, Hs::Vector{MPO}; recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.updateH!-Tuple{StateEnvs{ProjMPO_MPS2}, MPO, Vector{MPS}}","page":"StateEnvs","title":"TeNLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPO_MPS2}, H::MPO, Ms::Vector{MPS};\n                  weight::Float64, recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\nweight::Union{Nothing, Float64} = nothing.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.updateH!-Tuple{StateEnvs{ProjMPOSum_MPS}, Vector{MPO}, Vector{MPS}}","page":"StateEnvs","title":"TeNLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPOSum_MPS}, Hs::Vector{MPO}, Ms::Vector{MPS};\n                  weight::Float64, recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\nweight::Union{Nothing, Float64} = nothing.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#TeNLib.updateH!-Tuple{StateEnvs{ProjCouplingModel_MPS}, CouplingModel, Vector{MPS}}","page":"StateEnvs","title":"TeNLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjCouplingModel_MPS}, H::CouplingModel, Ms::Vector{MPS};\n                  weight::Float64, recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\nweight::Union{Nothing, Float64} = nothing.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#ITensors.nsite-Tuple{StateEnvs}","page":"StateEnvs","title":"ITensors.nsite","text":"function nsite(sysenv::StateEnvs)\n\nReturns the nsite of the environment. nsite = 1 for single-site environment, nsite = 2 for two-site environmrnt, and so on.  Currently, only uses nsite = 0, 1, or 2.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#ITensors.set_nsite!-Tuple{StateEnvs, Int64}","page":"StateEnvs","title":"ITensors.set_nsite!","text":"function set_nsite!(sysenv::StateEnvs, nsite::Int)\n\nSet nsite of the environment. nsite = 1 for single-site environment, nsite = 2 for two-site environmrnt, and so on.  Currently, only uses nsite = 0, 1, or 2.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#ITensors.position!-Tuple{StateEnvs, Int64}","page":"StateEnvs","title":"ITensors.position!","text":"function position!(sysenv::StateEnvs, pos::Int)\n\nCompute the left and right environments at position pos.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#Base.copy-Tuple{StateEnvs}","page":"StateEnvs","title":"Base.copy","text":"function Base.copy(sysenv::StateEnvs)\n\nShallow copy of StateEnvs.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs.html#Base.length-Tuple{StateEnvs}","page":"StateEnvs","title":"Base.length","text":"function Base.length(sysenv::StateEnvs)\n\nReturns the length of the underlying MPS/Environment.\n\n\n\n\n\n","category":"method"},{"location":"mps/update_site.html#Perform-local-updates","page":"Perform local updates","title":"Perform local updates","text":"","category":"section"},{"location":"mps/update_site.html","page":"Perform local updates","title":"Perform local updates","text":"At the lowest-level of abstraction, TeNLib allows for updating the StateEnvs for each sites/bonds manually.","category":"page"},{"location":"mps/update_site.html","page":"Perform local updates","title":"Perform local updates","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/update_site.html","page":"Perform local updates","title":"Perform local updates","text":"update_position!(sysenv::StateEnvs, solver, pos::Int, nsite::Int, ortho::String; kwargs...)","category":"page"},{"location":"mps/update_site.html#TeNLib.update_position!-Tuple{StateEnvs, Any, Int64, Int64, String}","page":"Perform local updates","title":"TeNLib.update_position!","text":"update_position!(sysenv::StateEnvs, solver, pos::Int, nsite::Int, ortho::String; kwargs...)\n\nUpdate StateEnvs at position pos by solver.\n\nArguments:\n\nsysenv::StateEnvs\nsolver: Solver for update. Available ones: eig_solver and exp_solver.\npos::Int: Position of the bond (nsite=2) or site (nsite=1).\nnsite of the environment. Either 1 or 2 for one-site or two-site update respectively.\northo::String: Direction of the sweep. Either \"left\" or \"right\".\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for TDVP. \nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nreverse_step::Bool = false if time_step = nothing, true otherwise.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14 if eig_solver, 1E-12 if exp_solver.\nsolver_krylovdim::Int = 5 if eig_solver, 30 if exp_solver.\nsolver_maxiter::Int = 2 if eig_solver, 100 if exp_solver.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false if eig_solver, true if exp_solver.\nsolver_check_convergence::Bool = false if eig_solver, true if exp_solver.\n\nReturn values:\n\n::Float64: Energy.\n::Float64: Truncation Error.\nVector{Float64}: SVD spectrum.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg.html#Performing-DMRG","page":"Performing DMRG","title":"Performing DMRG","text":"","category":"section"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"Functions to perfom (and control) DMRG runs.","category":"page"},{"location":"mps/dmrg.html#DMRGParams","page":"Performing DMRG","title":"DMRGParams","text":"","category":"section"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"TeNLib defines a struct, called  DMRGParams, to control DMRG simulations.","category":"page"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"DMRGParams\nDMRGParams(;maxdim::Vector{Int}, nsweeps::Vector{Int}, cutoff::Union{Vector{Float64}, Float64} = _Float64_Threshold, noise::Union{Vector{Float64}, Float64, Int} = 0.0, noisedecay::Union{Vector{Float64}, Float64, Int} = 1.0, disable_noise_after::Union{Vector{Int}, Int} = typemax(Int))\nBase.copy(params::DMRGParams)","category":"page"},{"location":"mps/dmrg.html#TeNLib.DMRGParams","page":"Performing DMRG","title":"TeNLib.DMRGParams","text":"mutable struct DMRGParams\n    maxdim::Vector{Int}\n    nsweeps::Vector{Int}\n    cutoff::Vector{Float64}\n    noise::Vector{Float64}\n    noisedecay::Vector{Float64}\n    disable_noise_after::Vector{Int}\nend\n\nHolds parameters to control DMRG sweeps.\n\nmaxdim::Vector{Int}: Maximum allowed MPS bond/link dimensions at each stages of DMRG.\nnsweeps::Vector{Int}: Number of sweeps to be performed at each statges of DMRG.\ncutoff::Vector{Float64}: Cutoff for SVD truncation at each stages of DMRG.\nnoise::Vector{Float64}: Noise level at each stages of DMRG.\nnoisedecay::Vector{Float64}: Decay of noise level at each states of DMRG. Noise is divided by noisedecay after each sweep.\ndisable_noise_after::Vector{Int}: Switch of noise after this many sweeps at each\n\nstates of DMRG.\n\nAll these Vectors must have same dimension.\n\n\n\n\n\n","category":"type"},{"location":"mps/dmrg.html#TeNLib.DMRGParams-Tuple{}","page":"Performing DMRG","title":"TeNLib.DMRGParams","text":"function DMRGParams(;maxdim::Vector{Int}, nsweeps::Vector{Int}, \n                    cutoff::Union{Vector{Float64}, Float64} = _Float64_Threshold,\n                    noise::Union{Vector{Float64}, Float64, Int} = 0.0,\n                    noisedecay::Union{Vector{Float64}, Float64, Int} = 1.0,\n                    disable_noise_after::Union{Vector{Int}, Int} = typemax(Int))\n\nConstructor for DMRGParams. Takes only named arguments.\n\nmaxdim::Vector{Int}: Maximum allowed MPS bond/link dimensions at each stages of DMRG.\nnsweeps::Vector{Int}: Number of sweeps to be performed at each statges of DMRG.\ncutoff::Union{Float64, Vector{Float64}} = Float64_threshold(): Cutoff for SVD truncation at each stages of DMRG. If Float64, cutoff remains same throughout the DMRG simulation. \nnoise::Union{Float64, Int, Vector{Float64}} = 0.0: Noise level at each stages of DMRG. If Float64 or Int, initial noise remains same throughout the DMRG simulation.\nnoisedecay::Union{Float64, Int, Vector{Float64}} = 1.0: Decay of noise level at each states of DMRG. Noise is divided by noisedecay after each sweep. If Float64 or Int, noisedecay remains same throughout the DMRG simulation.\ndisable_noise_after::Union{Int, Vector{Int}} = typemax(Int): Switch of noise after this many sweeps at each states of DMRG. If Int, disable_noise_after remains same throughout the DMRG simulation.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg.html#Base.copy-Tuple{DMRGParams}","page":"Performing DMRG","title":"Base.copy","text":"Base.copy(params::DMRGParams)\n\nShallow copy DMRGParams.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg.html#A-lower-level-DMRG-function","page":"Performing DMRG","title":"A lower level DMRG function","text":"","category":"section"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"Following function modifies StateEnvs in-place. Skip this function if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"dmrg!(sysenv::StateEnvs, params::DMRGParams, nsite::Int; kwargs...)","category":"page"},{"location":"mps/dmrg.html#TeNLib.dmrg!-Tuple{StateEnvs, DMRGParams, Int64}","page":"Performing DMRG","title":"TeNLib.dmrg!","text":"function dmrg!(sysenv::StateEnvs, params::DMRGParams, nsite::Int; kwargs...)\n\nPerforms DMRG.\n\nArguments:\n\nsysenv::StateEnvs.\nparams::DMRGParams.\nnsite::Int of the environment. Either 1 or 2 for one-site or two-site update respectively.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state DMRG. Must be set to greater than 0 for the excited state DMRG.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: DMRG (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\nentropyErrGoal: DMRG (at a particluar stage) stops when mid-chain entropy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nWhen both energyErrGoal and entropyErrGoal are given, both conditions must be satisfied to trigger this early stopping.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0.: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\nSweepData\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg.html#Higher-level-DMRG-functions","page":"Performing DMRG","title":"Higher level DMRG functions","text":"","category":"section"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"Standard two- and single-site DMRG functions. Single-site DMRG can increasing the bond-dimension if noise > Float64_threshold().","category":"page"},{"location":"mps/dmrg.html","page":"Performing DMRG","title":"Performing DMRG","text":"dmrg2(psi0::MPS, H::T, params::DMRGParams; kwargs...) where T <: Union{MPO, Vector{MPO}, CouplingModel}\ndmrg1(psi0::MPS, H::T, params::DMRGParams; kwargs...) where T <: Union{MPO, Vector{MPO}, CouplingModel}","category":"page"},{"location":"mps/dmrg.html#TeNLib.dmrg2-Union{Tuple{T}, Tuple{MPS, T, DMRGParams}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing DMRG","title":"TeNLib.dmrg2","text":"function dmrg2(psi0::MPS, H::MPO, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::CouplingModel, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, Hs::Vector{MPO}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::MPO, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::CouplingModel, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\n\nPerforms two-site DMRG.\n\nArguments:\n\npsi0::MPS: Initial MPS.\nH::MPO, H::CouplingModel, Hs::Vector{MPO}, Ms::Vector{MPS}.\nparams::DMRGParams.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state DMRG. Must be set to greater than 0 for the excited state DMRG.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: DMRG (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\nentropyErrGoal: DMRG (at a particluar stage) stops when mid-chain entropy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nWhen both energyErrGoal and entropyErrGoal are given, both conditions must be satisfied to trigger this early stopping.\n\nNamed arguments for eig_solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Energy.\n::MPS: The state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg.html#TeNLib.dmrg1-Union{Tuple{T}, Tuple{MPS, T, DMRGParams}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing DMRG","title":"TeNLib.dmrg1","text":"function dmrg1(psi0::MPS, H::MPO, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::CouplingModel, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, Hs::Vector{MPO}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::MPO, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::CouplingModel, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\n\nPerforms single-site DMRG. All other details are same as in dmrg2.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#OpStrings","page":"OpStrings","title":"OpStrings","text":"","category":"section"},{"location":"base/opstrings.html","page":"OpStrings","title":"OpStrings","text":"TeNLib provides an alternative, called OpStrings, to ITensors' OpSum to automatically construct Hamiltonains / operators. TeNLib's own CouplingModel is built from OpStrings and is not compatible with OpSum.","category":"page"},{"location":"base/opstrings.html#OpString","page":"OpStrings","title":"OpString","text":"","category":"section"},{"location":"base/opstrings.html","page":"OpStrings","title":"OpStrings","text":"OpStrings is basically a vector of OpString objects (notice the difference in 's' at the end)","category":"page"},{"location":"base/opstrings.html","page":"OpStrings","title":"OpStrings","text":"OpString\nTeNLib.coefficient(opstr::OpString)\noperators(opstr::OpString)\nminsite(opstr::OpString)\nmaxsite(opstr::OpString)\nremoveIds(opstr::OpString{T}) where {T <: Number}\nbosonize(opstr::OpString{T1}, sites::Vector{Index{T2}}) where {T1 <: Number, T2}","category":"page"},{"location":"base/opstrings.html#TeNLib.OpString","page":"OpStrings","title":"TeNLib.OpString","text":"struct OpString{T <: Number}\n    coeff::T\n    ops::Vector{Pair{String, Int}}\nend\n\nHolds operator strings (operator names with corresponding positions) along with the coefficient.\n\ncoeff::T: Coeffcient of the operator string.\nops::Vector{Pair{String, Int}}: String of operator names along with the positions.\n\n\n\n\n\n","category":"type"},{"location":"base/opstrings.html#TeNLib.coefficient-Tuple{OpString}","page":"OpStrings","title":"TeNLib.coefficient","text":"function coefficient(opstr::OpString)\n\nReturns the coefficient of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.operators-Tuple{OpString}","page":"OpStrings","title":"TeNLib.operators","text":"function operators(opstr::OpString)\n\nReturns the operator string of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.minsite-Tuple{OpString}","page":"OpStrings","title":"TeNLib.minsite","text":"function minsite(opstr::OpString)\n\nReturns the lowest site position in the operator string of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.maxsite-Tuple{OpString}","page":"OpStrings","title":"TeNLib.maxsite","text":"function maxsite(opstr::OpString)\n\nReturns the highest site position in the operator string of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.removeIds-Union{Tuple{OpString{T}}, Tuple{T}} where T<:Number","page":"OpStrings","title":"TeNLib.removeIds","text":"function removeIds(opstr::OpString{T}) where {T <: Number}\n\nReturns an OpString with all \"Id\" operators removed from the original.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.bosonize-Union{Tuple{T2}, Tuple{T1}, Tuple{OpString{T1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"OpStrings","title":"TeNLib.bosonize","text":"function bosonize(opstr::OpString{T1},\n                  sites::Vector{Index{T2}}) where {T1 <: Number, T2}\n\nReturns an OpString after \"bosonizing\" the original with Jordan-Wigner strings as needed. See bosonize.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#OpStrings-2","page":"OpStrings","title":"OpStrings","text":"","category":"section"},{"location":"base/opstrings.html","page":"OpStrings","title":"OpStrings","text":"OpStrings{T}\nremoveIdsZeros(os::OpStrings{T}) where {T <: Number}\nbosonize(os::OpStrings{T1}, sites::Vector{Index{T2}}) where {T1 <: Number, T2}\nmergeterms(os::OpStrings{T}) where T <: Number","category":"page"},{"location":"base/opstrings.html#TeNLib.OpStrings","page":"OpStrings","title":"TeNLib.OpStrings","text":"const OpStrings{T} = Vector{OpString{T}}\n\nCollection of OpStrings.\n\nSyntax:\n\nos = OpString()\nos += 1, \"Sx\" => i, \"Sx\" => j, \"Sx\" => k, ....\nos += \"Sx\" => i, \"Sx\" => j, \"Sx\" => k, ....\n\nExample:\n\nos = OpStrings()    \nfor j=1:N-1\n    os += 1, \"Sz\" => j, \"Sz\" => j+1\n    os += 0.5, \"S+\" => j, \"S-\" => j+1\n    os += 0.5, \"S-\" => j, \"S+\" => j+1\nend\n\n\n\n\n\n","category":"type"},{"location":"base/opstrings.html#TeNLib.removeIdsZeros-Union{Tuple{Array{OpString{T}, 1}}, Tuple{T}} where T<:Number","page":"OpStrings","title":"TeNLib.removeIdsZeros","text":"function removeIdsZeros(os::OpStrings{T}) where {T <: Number}\n\nReturns an OpStrings with all \"Id\" operators removed from the original, as well as any OpString term that has coeff less than Float64_threshold().\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.bosonize-Union{Tuple{T2}, Tuple{T1}, Tuple{Array{OpString{T1}, 1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"OpStrings","title":"TeNLib.bosonize","text":"function bosonize(os::OpStrings{T1}, sites::Vector{Index{T2}}) where {T1 <: Number, T2}\n\nReturns an OpStrings after \"bosonizing\" the original with Jordan-Wigner strings as needed. See bosonize.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#TeNLib.mergeterms-Union{Tuple{Array{OpString{T}, 1}}, Tuple{T}} where T<:Number","page":"OpStrings","title":"TeNLib.mergeterms","text":"function mergeterms(os::OpStrings{T}) where T <: Number\n\nReturns an OpStrings where OpString elements with exactly same operator strings has been merged by adding the coefficients.  \n\n\n\n\n\n","category":"method"},{"location":"base/opstrings.html#MPO-from-OpStrings","page":"OpStrings","title":"MPO from OpStrings","text":"","category":"section"},{"location":"base/opstrings.html","page":"OpStrings","title":"OpStrings","text":"ITensors.MPO(os::OpStrings{T1}, sites::Vector{Index{T2}}; maxdim::Int = typemax(Int), mindim::Int = 1, cutoff::Float64 = Float64_threashold(), svd_alg::String = \"divide_and_conquer\", chunksize::Int = 12) where {T1 <: Number, T2}","category":"page"},{"location":"base/opstrings.html#ITensors.MPO-Union{Tuple{T2}, Tuple{T1}, Tuple{Array{OpString{T1}, 1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"OpStrings","title":"ITensors.MPO","text":"function ITensors.MPO(os::OpStrings{T1},\n                      sites::Vector{Index{T2}};\n                      maxdim::Int = typemax(Int),\n                      mindim::Int = 1,\n                      cutoff::Float64 = Float64_threashold(),\n                      svd_alg::String = \"divide_and_conquer\",\n                      chunksize::Int = 12) where {T1 <: Number, T2}\n\nCreates MPO from os::OpStrings. The present version uses recursive SVDs to create the MPO. Very inefficient when number of Hamiltonian terms is large. Future updates will solve the problem.\n\nNamed arguments and their default values:\n\nmaxdim::Int = typemax(Int): Maximum MPO bond dimension after SVD truncation.\nmindim::Int = 1: Minimum MPO bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nchunksize::Int = 12. Maximum size of the chunks on which recursive SVDs are performed.\n\n\n\n\n\n","category":"method"},{"location":"dmrg.html#DMRG-Functions","page":"DMRG Functions","title":"DMRG Functions","text":"","category":"section"},{"location":"dmrg.html","page":"DMRG Functions","title":"DMRG Functions","text":"dmrg!\ndmrg2\ndmrg1","category":"page"},{"location":"dmrg.html#TeNLib.dmrg!","page":"DMRG Functions","title":"TeNLib.dmrg!","text":"function dmrg!(sysenv::StateEnvs, params::DMRGParams, nsite::Int; kwargs...)\n\nPerforms DMRG.\n\nArguments:\n\nsysenv::StateEnvs.\nparams::DMRGParams.\nnsite::Int of the environment. Either 1 or 2 for one-site or two-site update respectively.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state DMRG. Must be set to greater than 0 for the excited state DMRG.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: DMRG (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\nentropyErrGoal: DMRG (at a particluar stage) stops when mid-chain entropy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nWhen both energyErrGoal and entropyErrGoal are given, both conditions must be satisfied to trigger this early stopping.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0.: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\nSweepData\n\n\n\n\n\n","category":"function"},{"location":"dmrg.html#TeNLib.dmrg2","page":"DMRG Functions","title":"TeNLib.dmrg2","text":"function dmrg2(psi0::MPS, H::MPO, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::CouplingModel, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, Hs::Vector{MPO}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::MPO, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::CouplingModel, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\n\nPerforms two-site DMRG.\n\nArguments:\n\npsi0::MPS: Initial MPS.\nH::MPO, H::CouplingModel, Hs::Vector{MPO}, Ms::Vector{MPS}.\nparams::DMRGParams.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state DMRG. Must be set to greater than 0 for the excited state DMRG.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: DMRG (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\nentropyErrGoal: DMRG (at a particluar stage) stops when mid-chain entropy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nWhen both energyErrGoal and entropyErrGoal are given, both conditions must be satisfied to trigger this early stopping.\n\nNamed arguments for eig_solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Energy.\n::MPS: The state psi.\n\n\n\n\n\n","category":"function"},{"location":"dmrg.html#TeNLib.dmrg1","page":"DMRG Functions","title":"TeNLib.dmrg1","text":"function dmrg1(psi0::MPS, H::MPO, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::CouplingModel, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, Hs::Vector{MPO}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::MPO, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::CouplingModel, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\n\nPerforms single-site DMRG. All other details are same as in dmrg2.\n\n\n\n\n\n","category":"function"},{"location":"base/fermions.html#Dealing-with-Fermions","page":"Dealing with Fermions","title":"Dealing with Fermions","text":"","category":"section"},{"location":"base/fermions.html","page":"Dealing with Fermions","title":"Dealing with Fermions","text":"TeNLib uses the following function to teat fermionic operators.","category":"page"},{"location":"base/fermions.html","page":"Dealing with Fermions","title":"Dealing with Fermions","text":"bosonize(oppair::Vector{Pair{String, Int}},sites::Vector{Index{T}}) where T","category":"page"},{"location":"base/fermions.html#TeNLib.bosonize-Union{Tuple{T}, Tuple{Vector{Pair{String, Int64}}, Array{Index{T}, 1}}} where T","page":"Dealing with Fermions","title":"TeNLib.bosonize","text":"function bosonize(oppair::Vector{Pair{String, Int}},\n                  sites::Vector{Index{T}}) where T\n\nGiven a string of operator names with positions in the form of Vector{Pair{String, Int}} \"bosonizes\" the operator string by putting the Jordan-Wigner string \"F\" at appropriate places.\n\nArguments\n\noppair::Vector{Pair{String, Int}}: Input string of operator names with positions.\nsites::Vector{Index}: The entire site Indexs as per ITensors' convention.\n\nReturn values\n\n::Int: Even (+1) or odd (-1) permutation.\n::Vector{Pair{String, Int}}:  modified string of operator names and positions.\n\n\n\n\n\n","category":"method"},{"location":"index.html#TeNLib","page":"Introduction","title":"TeNLib","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A Tensor Network Library (TeNLib) built on top of ITensors.jl for quantum many-body problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Build Status Documentation\n(Image: Build Status) (Image: Build Status)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The source code for TeNLib can be found on GitHub","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The documentation for TeNLib can be found here.","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"TeNLib features popular Tensor Network (TN) codes with multi-layered abstraction, that provides varying levels of control to the user. Currently, TeNLib contains codes for","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(a) Finite-size Matrix-Product States (MPS): Different variants of DMRG and TDVP (including subspace expansion).\n(b) Tree Tensor Network (TTN): Variational search for the ground state and first few excited states.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Currently, TeNLib.jl is not registered on Julia General Registry. To install the library (along with ITensors.jl), you can use the following steps:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"$ julia\n\njulia> ]\n\npkg> add ITensors\n\npkg> add https://github.com/titaschanda/TeNLib.jl","category":"page"},{"location":"index.html#Future-functionality?","page":"Introduction","title":"Future functionality?","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Here is a list for future additions in the decreasing order of priority. Any help / suggestion is welcome.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Augmented Tree Tensor Network (aTTN) for variational ground state search for 2D problems.\nInfinite DMRG (iDMRG) and/or Variational Uniform Matrix Product States (VUMPS) to tackle 1D / quasi-1D problems directly at the thermodynamic limit.\nProjected Entangled Pair States (PEPS) for 2D problems.\nReal-time evolution method using PEPS and TTN.","category":"page"},{"location":"index.html#Example:-A-simple-DMRG-code","page":"Introduction","title":"Example: A simple DMRG code","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The following code is for a simple DMRG run at the highest level of abstraction without any additional control.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using ITensors\nusing TeNLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpSum()\n    \n    for j=1:N-1\n        os += 1, \"Sz\", j,\"Sz\", j+1\n        os += 0.5, \"S+\", j, \"S-\", j+1\n        os += 0.5, \"S-\", j, \"S+\", j+1\n    end\n    \n    H = MPO(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    params = DMRGParams(;nsweeps = [5, 5], maxdim = [20, 50],\n                        cutoff = 1e-14, noise = 1e-3, noisedecay = 2,\n                        disable_noise_after = 3)\n\n    # dmrg2 for two-site DMRG\n    en, psi = dmrg2(psi0, H, params)\nend","category":"page"},{"location":"index.html#Example:-A-simple-TDVP-code","page":"Introduction","title":"Example: A simple TDVP code","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The following code is for a simple TDVP run at the highest level of abstraction without any additional control.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using ITensors\nusing TeNLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpSum()\n    \n    for j=1:N-1\n        os += 1, \"Sz\", j,\"Sz\", j+1\n        os += 0.5, \"S+\", j, \"S-\", j+1\n        os += 0.5, \"S-\", j, \"S+\", j+1\n    end\n    \n    H = MPO(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    tau = -0.01im    \n    engine = TDVPEngine(psi0, H)\n    for ii = 1:100\n\n    \t# `nsite = \"dynamic\"` for dynamical selection between\n\t# single- and two-site variants at different bonds\n        tdvpsweep!(engine, tau,\n                   nsite = \"dynamic\";\n                   maxdim = 200,\n                   cutoff = 1E-12,\n                   extendat = 5)\n\n\tpsi = getpsi(engine)\n\t# DO STUFF\n    end\nend","category":"page"},{"location":"index.html#Example:-A-simple-TTN-ground-state-optimzation-code","page":"Introduction","title":"Example: A simple TTN ground-state optimzation code","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The following code is for a simple TTN ground-state optimzation run at the highest level of abstraction without any additional control. Here we use OpStrings and CouplingModel instead of OpSum and MPO.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using ITensors\nusing TeNLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpStrings()\n    \n    for j=1:N-1\n        os += 1, \"Sz\" => j,\"Sz\" => j+1\n        os += 0.5, \"S+\" =>j, \"S-\" => j+1\n        os += 0.5, \"S-\"=>j, \"S+\" => j+1\n    end\n    \n    H = CouplingModel(os,sites)\n    psi0 = TTN(sites, 64, QN(\"Sz\", 0))\n\n    sweeppath = default_sweeppath(psi0)\n    \n    params = OptimizeParamsTTN(; maxdim = [64, 128], nsweeps = [5, 10], \n                               cutoff = 1e-14, noise = 1e-2, noisedecay = 5, \n                               disable_noise_after = 5)\n\t\t\t       \n    en, psi = optimize(psi0, H, params, sweeppath)\nend","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Note: OpStrings and CouplingModel can be also used for MPS based codes without modifying other parts of the code.","category":"page"},{"location":"mps/sweep.html#Sweeping-through-the-MPS","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"","category":"section"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"At a lower level of abstraction, TeNLib allows to control each fullsweep (left-to-right and right-to-left) manually to update StateEnvs.","category":"page"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/sweep.html#SweepData","page":"Sweeping through the MPS","title":"SweepData","text":"","category":"section"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"TeNLib defines a struct, called  SweepData, to store essential data after each fullsweep.","category":"page"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"SweepData\nBase.copy(swdata::SweepData)","category":"page"},{"location":"mps/sweep.html#TeNLib.SweepData","page":"Sweeping through the MPS","title":"TeNLib.SweepData","text":"mutable struct SweepData\n    sweepcount::Int\n    maxchi::Vector{Int}\n    energy::Vector{Float64}\n    entropy::Vector{Float64}\n    maxtruncerr::Vector{Float64}\n    lasteigs::Vector{Vector{Float64}}\nend\n\nHolds historical data after each (full)sweep. Requires for convergence check etc.\n\nsweepcount::Int: Number of fullsweeps performed.\nmaxchi::Vector{Int}: Maximum MPS bond/link dimensions after every sweep.\nenergy::Vector{Float64}: Energies after every sweep.\nentropy::Vector{Float64}: Mid-chain entropies after every sweep.\nmaxtrucerr::Vector{Float64}: Maximum truncation error after every sweep.\nlasteigs::Vector{Vector{Float64}}: Spectrum of eigenvalues at each bond after previous halfsweep.\n\nDefault constructor:\n\nSweepData(): Initialize an empty SweepData object. Required to call following functions\n\nat the first time.\n\n\n\n\n\n","category":"type"},{"location":"mps/sweep.html#Base.copy-Tuple{SweepData}","page":"Sweeping through the MPS","title":"Base.copy","text":"Base.copy(swdata::SweepData)\n\nShallow copy of SweepData.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep.html#Perform-a-fullsweep","page":"Sweeping through the MPS","title":"Perform a fullsweep","text":"","category":"section"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"fullsweep!(sysenv::StateEnvs, solver, nsite::Int, swdata::SweepData; kwargs...)","category":"page"},{"location":"mps/sweep.html#TeNLib.fullsweep!-Tuple{StateEnvs, Any, Int64, SweepData}","page":"Sweeping through the MPS","title":"TeNLib.fullsweep!","text":"function fullsweep!(sysenv::StateEnvs, solver, nsite::Int, swdata::SweepData;\n                    kwargs...)\n\nPerform a fullsweep (left-to-right and right-to-left) by solver.\n\nArguments:\n\nsysenv::StateEnvs.\nsolver: Solver for update. Available ones: eig_solver and exp_solver.\nnsite::Int of the environment. Either 1 or 2 for one-site or two-site update  respectively.\nswdata::SweepData.\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for TDVP. \nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nreverse_step::Bool = false if time_step = nothing, true otherwise.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14 if eig_solver, 1E-12 if exp_solver.\nsolver_krylovdim::Int = 5 if eig_solver, 30 if exp_solver.\nsolver_maxiter::Int = 2 if eig_solver, 100 if exp_solver.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false if eig_solver, true if exp_solver.\nsolver_check_convergence::Bool = false if eig_solver, true if exp_solver.\n\nReturn values:\n\n::Float64: Change in Energy ΔE\n::Float64: Change in Entropy ΔS\n\nswdata::SweepData gets updated.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep.html#Perform-a-dynamical-fullsweep","page":"Sweeping through the MPS","title":"Perform a dynamical fullsweep","text":"","category":"section"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"TeNLib defines the following function to dynamically decide whether to perform single- or two-site update at each bond, depending on the entropy growth at the previous halfsweep.","category":"page"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"dynamic_fullsweep!(sysenv::StateEnvs, solver, swdata::SweepData; kwargs...)","category":"page"},{"location":"mps/sweep.html#TeNLib.dynamic_fullsweep!-Tuple{StateEnvs, Any, SweepData}","page":"Sweeping through the MPS","title":"TeNLib.dynamic_fullsweep!","text":"function dynamic_fullsweep!(sysenv::StateEnvs, solver, swdata::SweepData;\n                            kwargs...)\n\nPerform a dynamic fullsweep (left-to-right and right-to-left) by solver. The very first sweep, as dictated by swdata.sweepcount=0, Global Subspace Expansion (see below) is performed followed by a pure one-site sweep if typeof(sysenv) == StateEnvs{ProjMPO}, else performs a full two-site sweep. At each bond, if the lowest eigenvalue is below eigthreshold or the bond dimension at that bond has reached maxdim at a particular halfsweep, performs single-site update across that bond in the subsequent halfsweep, otherwise performs two-site update.\n\nArguments:\n\nsysenv::StateEnvs.\nsolver: Solver for update. Available ones: eig_solver and exp_solver.\nswdata::SweepData.\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for TDVP. \nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nreverse_step::Bool = false if time_step = nothing, true otherwise.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\neigthreshold::Float64 = 1E-12.\nextendat::Union{Nothing, Int} = nothing: If specified, at every extendatth sweep, Global Subspace Expansion is performed followed by a pure one-site sweep if typeof(sysenv) == StateEnvs{ProjMPO}, else performs a full two-site sweep.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14 if eig_solver, 1E-12 if exp_solver.\nsolver_krylovdim::Int = 3 if eig_solver, 30 if exp_solver.\nsolver_maxiter::Int = 1 if eig_solver, 100 if exp_solver.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false if eig_solver, true if exp_solver.\nsolver_check_convergence::Bool = false if eig_solver, true if exp_solver.\n\nArguments for Global Subspace Expansion and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = 0.0: Cutoff for the application of the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension for the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\nReturn values:\n\n::Float64: Change in Energy ΔE\n::Float64: Change in Entropy ΔS\n\nswdata::SweepData gets updated.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep.html#Global-Subspace-Expansion","page":"Sweeping through the MPS","title":"Global Subspace Expansion","text":"","category":"section"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"Following Phys. Rev. B 102, 094315 (2020), a Global Subspace Expansion can be performed using Krylov subspace if the environments are created by a single MPO.","category":"page"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"Apart from TDVP, Global Subspace Expansion is also very useful for DMRG to get rid of nasty local minimas.","category":"page"},{"location":"mps/sweep.html","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"krylov_extend!(psi::MPS, H::MPO; kwargs...)\nkrylov_extend!(sysenv::StateEnvs{ProjMPO}; kwargs...)","category":"page"},{"location":"mps/sweep.html#TeNLib.krylov_extend!-Tuple{MPS, MPO}","page":"Sweeping through the MPS","title":"TeNLib.krylov_extend!","text":"function krylov_extend!(psi::MPS, H::MPO; kwargs...)\n\nPerforms Global Subspace Expansion.\n\nArguments and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep.html#TeNLib.krylov_extend!-Tuple{StateEnvs{ProjMPO}}","page":"Sweeping through the MPS","title":"TeNLib.krylov_extend!","text":"function krylov_extend!(sysenv::StateEnvs{ProjMPO}; kwargs...)\n\nPerforms Global Subspace Expansion. The StateEnvs must be created by a single MPO.\n\nArguments and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"method"}]
}
